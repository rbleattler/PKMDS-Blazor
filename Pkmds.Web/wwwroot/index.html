<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0"
          name="viewport"/>
    <title>PKMDS: PokÃ©mon Save Editor for Web</title>
    <base href="/"/>
    <link href="manifest.webmanifest"
          rel="manifest"/>
    <link href="_content/MudBlazor/MudBlazor.min.css"
          rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap"
          rel="stylesheet"/>
    <link href="_content/Pkmds.Rcl/css/tailwind.css"
          rel="stylesheet"/>
    <link href="_content/Pkmds.Rcl/css/app.css"
          rel="stylesheet"/>
    <link href="Pkmds.Web.styles.css"
          rel="stylesheet"/>
    <link href="_content/Pkmds.Rcl/icon-512.png"
          rel="apple-touch-icon"
          sizes="512x512"
          type="image/png"/>
    <link href="_content/Pkmds.Rcl/icon-192.png"
          rel="apple-touch-icon"
          sizes="192x192"
          type="image/png"/>
    <link href="_content/Pkmds.Rcl/icon-32.png"
          rel="apple-touch-icon"
          sizes="32x32"
          type="image/png"/>
    <link href="_content/Pkmds.Rcl/icon-32.png"
          rel="icon"
          type="image/png"/>
    <script type="importmap"></script>
</head>

<body>

<div class="status-bar-safe-area"></div>

<div id="app">
    <svg class="loading-progress">
        <circle cx="50%"
                cy="50%"
                r="40%"/>

        <circle cx="50%"
                cy="50%"
                r="40%"/>
    </svg>

    <div class="loading-progress-text"></div>
</div>

<div id="blazor-error-ui">

    An unhandled error has occurred.

    <a class="reload"
       href="">
        Reload
    </a>

    <a class="dismiss">ðŸ—™</a>

</div>

<script src="_content/Pkmds.Rcl/js/fileSave.js"></script>

<!--prevent autostarting-->
<script autostart="false"
        src="_framework/blazor.webassembly#[.{fingerprint}].js"></script>

<script>
    // Store the registration promise globally so checkForUpdate can use it
    if ('serviceWorker' in navigator) {
        window._swRegistrationPromise = navigator.serviceWorker.register('service-worker.js', {updateViaCache: 'none'}).then(registration => {
            console.info('Service worker registered, scope:', registration.scope);
            setInterval(() => registration.update().catch(err => {
                // Safari may throw "newestWorker is null" â€” this is benign
                if (!(err.name === 'InvalidStateError' || (err.message && err.message.includes('newestWorker is null')))) {
                    console.warn('Periodic registration.update() failed:', err);
                }
            }), 60 * 60 * 1000); // check for updates every hour
            registration.onupdatefound = () => {
                const installingWorker = registration.installing;
                installingWorker.onstatechange = () => {
                    if (installingWorker.state === 'installed' && navigator.serviceWorker.controller) {
                        // Notify Blazor about the update
                        window.dispatchEvent(new CustomEvent('updateAvailable'));
                    }
                };
            };
            return registration;
        }).catch(err => {
            console.error('Service worker registration failed:', err);
            return null;
        });
    } else {
        console.warn('Service workers are not supported in this browser.');
        window._swRegistrationPromise = Promise.resolve(null);
    }
</script>
<script src="_content/MudBlazor/MudBlazor.min.js"></script>
<script src="js/lib/crypto-js/crypto-js.min.js"></script>

<script>
    //check if webassembly is supported
    const webassemblySupported = (function () {
        try {
            if (typeof WebAssembly === "object"
                && typeof WebAssembly.instantiate === "function") {
                const module = new WebAssembly.Module(
                    Uint8Array.of(0x0, 0x61, 0x73, 0x6d,
                        0x01, 0x00, 0x00, 0x00));
                if (module instanceof WebAssembly.Module)
                    return new WebAssembly.Instance(module)
                        instanceof WebAssembly.Instance;
            }
        } catch (e) {
        }
        return false;
    })();
    // Modern browsers e.g. Microsoft Edge
    if (webassemblySupported) {
        Blazor.start({});
    }
    // Older browsers e.g. IE11
    else {
        window.location = window.location + "BrowserNotSupported.html";
    }
</script>

<script>
    window.addUpdateListener = () => {
        window.addEventListener('updateAvailable', () => {
            DotNet.invokeMethodAsync('Pkmds.Web', 'ShowUpdateMessage');
        });
    };

    window.checkForUpdate = async () => {
        if (!('serviceWorker' in navigator)) {
            return { result: 'no-sw', detail: 'Service workers not supported by this browser.' };
        }
        try {
            // Use the stored registration promise from initial registration
            let registration = window._swRegistrationPromise
                ? await window._swRegistrationPromise
                : null;
            const fromStored = !!registration;
            // Fall back to getRegistration if the stored promise resolved to null
            if (!registration) {
                registration = await navigator.serviceWorker.getRegistration();
            }
            if (!registration) {
                return {
                    result: 'no-sw',
                    detail: fromStored
                        ? 'Registration promise resolved to null.'
                        : 'No stored registration and getRegistration() returned null.'
                };
            }
            // If a waiting worker already exists before we call update(), an update is pending
            if (registration.waiting) {
                return { result: 'update-found', detail: 'A waiting worker was already present.' };
            }
            // Remember the current active worker so we can detect if it actually changed
            const previousActive = registration.active;
            // Listen for the updatefound event, then call update()
            return await new Promise(resolve => {
                let resolved = false;
                const done = (result, detail) => {
                    if (resolved) return;
                    resolved = true;
                    registration.removeEventListener('updatefound', onUpdateFound);
                    resolve({ result, detail: detail || '' });
                };
                const onUpdateFound = () => {
                    const newWorker = registration.installing;
                    if (!newWorker) {
                        done('no-update', 'updatefound fired but no installing worker.');
                        return;
                    }
                    // Wait for the new worker to finish installing
                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'installed') {
                            done('update-found', 'New worker installed and waiting.');
                        } else if (newWorker.state === 'activated') {
                            if (previousActive && registration.active === previousActive) {
                                done('no-update', 'Worker re-activated but is the same instance.');
                            } else {
                                done('update-found', 'New worker activated.');
                            }
                        } else if (newWorker.state === 'redundant') {
                            done('no-update', 'New worker became redundant.');
                        }
                    });
                };
                registration.addEventListener('updatefound', onUpdateFound);
                registration.update().catch(err => {
                    // Some browsers (e.g. Safari) throw "newestWorker is null" InvalidStateError
                    // when calling update() and the SW is already active with no pending update.
                    // This is not a real error â€” it means we're already up to date.
                    if (err.name === 'InvalidStateError' || (err.message && err.message.includes('newestWorker is null'))) {
                        console.info('registration.update() threw InvalidStateError (newestWorker is null) â€” treating as no update available.');
                        done('no-update', 'Service worker is up to date (no pending update).');
                    } else {
                        console.warn('registration.update() failed:', err);
                        done('error', 'update() threw: ' + err.message);
                    }
                });
                setTimeout(() => done('no-update', 'Timed out after 8 seconds.'), 8000);
            });
        } catch (error) {
            console.warn('checkForUpdate error:', error);
            return { result: 'error', detail: error.message };
        }
    };
</script>

</body>

</html>
