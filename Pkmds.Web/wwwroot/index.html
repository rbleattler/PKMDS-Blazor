<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0"
          name="viewport"/>
    <title>PKMDS: PokÃ©mon Save Editor for Web</title>
    <base href="/"/>
    <link href="manifest.webmanifest"
          rel="manifest"/>
    <link href="_content/MudBlazor/MudBlazor.min.css"
          rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap"
          rel="stylesheet"/>
    <link href="_content/Pkmds.Rcl/css/tailwind.css"
          rel="stylesheet"/>
    <link href="_content/Pkmds.Rcl/css/app.css"
          rel="stylesheet"/>
    <link href="Pkmds.Web.styles.css"
          rel="stylesheet"/>
    <link href="_content/Pkmds.Rcl/icon-512.png"
          rel="apple-touch-icon"
          sizes="512x512"
          type="image/png"/>
    <link href="_content/Pkmds.Rcl/icon-192.png"
          rel="apple-touch-icon"
          sizes="192x192"
          type="image/png"/>
    <link href="_content/Pkmds.Rcl/icon-32.png"
          rel="apple-touch-icon"
          sizes="32x32"
          type="image/png"/>
    <link href="_content/Pkmds.Rcl/icon-32.png"
          rel="icon"
          type="image/png"/>
    <script type="importmap"></script>
</head>

<body>

<div class="status-bar-safe-area"></div>

<div id="app">
    <svg class="loading-progress">
        <circle cx="50%"
                cy="50%"
                r="40%"/>

        <circle cx="50%"
                cy="50%"
                r="40%"/>
    </svg>

    <div class="loading-progress-text"></div>
</div>

<div id="blazor-error-ui">

    An unhandled error has occurred.

    <a class="reload"
       href="">
        Reload
    </a>

    <a class="dismiss">ðŸ—™</a>

</div>

<script src="_content/Pkmds.Rcl/js/fileSave.js"></script>

<!--prevent autostarting-->
<script autostart="false"
        src="_framework/blazor.webassembly#[.{fingerprint}].js"></script>

<script>
    navigator.serviceWorker.register('service-worker.js', {updateViaCache: 'none'}).then(registration => {
        setInterval(() => registration.update(), 1 * 60 * 60 * 1000); // check for updates every hour
        registration.onupdatefound = () => {
            const installingWorker = registration.installing;
            installingWorker.onstatechange = () => {
                if (installingWorker.state === 'installed' && navigator.serviceWorker.controller) {
                    // Notify Blazor about the update
                    window.dispatchEvent(new CustomEvent('updateAvailable'));
                }
            };
        };
    });
</script>
<script src="_content/MudBlazor/MudBlazor.min.js"></script>
<script src="js/lib/crypto-js/crypto-js.min.js"></script>

<script>
    //check if webassembly is supported
    const webassemblySupported = (function () {
        try {
            if (typeof WebAssembly === "object"
                && typeof WebAssembly.instantiate === "function") {
                const module = new WebAssembly.Module(
                    Uint8Array.of(0x0, 0x61, 0x73, 0x6d,
                        0x01, 0x00, 0x00, 0x00));
                if (module instanceof WebAssembly.Module)
                    return new WebAssembly.Instance(module)
                        instanceof WebAssembly.Instance;
            }
        } catch (e) {
        }
        return false;
    })();
    // Modern browsers e.g. Microsoft Edge
    if (webassemblySupported) {
        Blazor.start({});
    }
    // Older browsers e.g. IE11
    else {
        window.location = window.location + "BrowserNotSupported.html";
    }
</script>

<script>
    window.addUpdateListener = () => {
        window.addEventListener('updateAvailable', () => {
            DotNet.invokeMethodAsync('Pkmds.Web', 'ShowUpdateMessage');
        });
    };

    window.checkForUpdate = async () => {
        if (!('serviceWorker' in navigator)) {
            return 'no-sw';
        }
        try {
            // Try getRegistration first; fall back to ready with a timeout
            let registration = await navigator.serviceWorker.getRegistration();
            if (!registration) {
                registration = await Promise.race([
                    navigator.serviceWorker.ready,
                    new Promise(resolve => setTimeout(() => resolve(null), 3000)),
                ]);
            }
            if (!registration) {
                return 'no-sw';
            }
            // If a waiting worker already exists before we call update(), an update is pending
            if (registration.waiting) {
                return 'update-found';
            }
            // Remember the current active worker so we can detect if it actually changed
            const previousActive = registration.active;
            // Listen for the updatefound event, then call update()
            return await new Promise(resolve => {
                let resolved = false;
                const done = (result) => {
                    if (resolved) return;
                    resolved = true;
                    registration.removeEventListener('updatefound', onUpdateFound);
                    resolve(result);
                };
                const onUpdateFound = () => {
                    const newWorker = registration.installing;
                    if (!newWorker) {
                        done('no-update');
                        return;
                    }
                    // Wait for the new worker to finish installing
                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'installed') {
                            // A new worker is installed and waiting â€” genuine update
                            done('update-found');
                        } else if (newWorker.state === 'activated') {
                            // Worker activated (skipWaiting) â€” check if it's actually different
                            if (previousActive && registration.active === previousActive) {
                                // Same worker reference, no real update
                                done('no-update');
                            } else {
                                done('update-found');
                            }
                        } else if (newWorker.state === 'redundant') {
                            // Installation failed or was superseded
                            done('no-update');
                        }
                    });
                };
                registration.addEventListener('updatefound', onUpdateFound);
                // Call update() â€” if a new SW is found, the event fires
                registration.update().catch(err => {
                    console.warn('registration.update() failed:', err);
                    done('error');
                });
                // If no update is found within 8 seconds, assume we're up to date
                setTimeout(() => done('no-update'), 8000);
            });
        } catch (error) {
            console.warn('checkForUpdate error:', error);
            return 'error';
        }
    };
</script>

</body>

</html>
